"use client";

import type { ProjectState, PaletteId, BuildIntentId, PrimarySurface, IntentIntakeV1 } from "./types";
import { APP_VERSION } from "./version";
import { stableJsonText } from "./stable_json";
import { sha256Hex } from "./hash";
import { recommendedPalettes } from "./recommendations";
import { applyDerivedTemplates } from "./templates";

function sortById<T extends { id?: any }>(items: any[]): any[] {
  const copy = Array.isArray(items) ? [...items] : [];
  copy.sort((a, b) => {
    const ia = String((a as any)?.id || "").toLowerCase();
    const ib = String((b as any)?.id || "").toLowerCase();
    if (ia < ib) return -1;
    if (ia > ib) return 1;
    return 0;
  });
  return copy;
}

// ---------------------------------------------------------------------------
// Intent Pack (Director-facing, deterministic)
// ---------------------------------------------------------------------------

export type IntentPackV1 = {
  schema: "kindred.intent_pack.v1";
  generator: {
    app_version: string;
    generated_at_utc: string;
  };
  project: {
    id: string;
    name: string;
    created_at_utc: string;
  };
  intent: {
    launch_path_id?: string;
    build_intent?: BuildIntentId;
    primary_surface?: PrimarySurface;
    palettes: PaletteId[];
    intake?: IntentIntakeV1;
    constraints: {
      offline_first: boolean;
      no_payments: boolean;
      required_env_names?: string[];
    };
    brief: {
      audience_description: string;
      problem: string;
      offer: string;
      differentiators: string[];
      key_actions: string[];
      success_metrics: string[];
      non_goals: string[];
    };
  };
  design: {
    brand: {
      name: string;
      tagline: string;
      audience: "general_public" | "builders" | "teams";
      tone: "serious" | "friendly" | "bold" | "calm";
    };
    tokens: ProjectState["design"]["tokens"];
  };
  // Optional deterministic DSL seed (advanced / Council-facing).
  spel_seed?: {
    schema: "kindred.spel_seed.v1";
    text: string;
  };
};

export type IntentProposalV1 = {
  schema: "kindred.intent_proposal.v1";
  id: "mvp" | "balanced" | "expansion";
  title: string;
  tagline: string;
  rationale: string[];
  recommended: {
    build_intent: BuildIntentId;
    primary_surface: PrimarySurface;
    palettes: PaletteId[];
  };
  notes: string[];
};

function utcNow(): string {
  return new Date().toISOString();
}

function safeList(raw: any): string[] {
  if (!Array.isArray(raw)) return [];
  return raw
    .map((x) => String(x || "").trim())
    .filter((x) => x.length > 0)
    .slice(0, 64);
}

export function generateSPELFromState(state: ProjectState): string {
  const palettes = Array.isArray(state.intent?.palettes) ? [...state.intent.palettes] : [];
  palettes.sort();
  const actors = sortById(Array.isArray(state.kernel_min?.actors) ? state.kernel_min.actors : []);
  const scenes = sortById(Array.isArray(state.kernel_min?.scenes) ? state.kernel_min.scenes : []);
  const flows = sortById(Array.isArray(state.kernel_min?.flows) ? state.kernel_min.flows : []);

  const entryId = scenes.find((s) => s && (s as any).entry)?.id || scenes[0]?.id || "home";
  const defaultActorId = actors[0]?.id || "visitor";

  const out: string[] = [];
  out.push(`# hello.spel (seed)`);
  out.push(`# Generated by Kindred ${APP_VERSION}`);
  out.push("");

  out.push("palettes:");
  if (palettes.length === 0) out.push("  - content_media");
  else for (const p of palettes) out.push(`  - ${p}`);
  out.push("");

  out.push("actors:");
  if (actors.length === 0) {
    out.push("  visitor:");
    out.push("    display_name: Visitor");
  } else {
    for (const a of actors) {
      const id = String(a?.id || "").trim();
      if (!id) continue;
      const name = String((a as any).display_name || id).trim() || id;
      out.push(`  ${id}:`);
      out.push(`    display_name: ${JSON.stringify(name)}`);
    }
  }
  out.push("");

  out.push("scenes:");
  if (scenes.length === 0) {
    out.push("  home:");
    out.push("    title: \"Home\"");
    out.push("    entry: true");
    out.push(`    actors: [${defaultActorId}]`);
  } else {
    for (const s of scenes) {
      const id = String((s as any)?.id || "").trim();
      if (!id) continue;
      const title = String((s as any)?.title || id).trim() || id;
      out.push(`  ${id}:`);
      out.push(`    title: ${JSON.stringify(title)}`);
      if (id === entryId) out.push("    entry: true");
      out.push(`    actors: [${defaultActorId}]`);
    }
  }
  out.push("");

  out.push("flows:");
  if (flows.length === 0) {
    out.push("  - id: primary");
    out.push(`    scenes: [${entryId}]`);
  } else {
    for (const f of flows) {
      const id = String((f as any)?.id || "").trim() || "primary";
      const sc = Array.isArray((f as any)?.scenes) ? (f as any).scenes : [];
      const list = sc.length > 0 ? sc.join(", ") : entryId;
      out.push(`  - id: ${id}`);
      out.push(`    scenes: [${list}]`);
    }
  }

  out.push("");
  return out.join("\n");
}

export type IntentPackBuildOptions = {
  include_spel_seed?: boolean;
};

export function buildIntentPackFromStateWithOptions(state: ProjectState, options?: IntentPackBuildOptions): IntentPackV1 {
  const required_env_names = safeList(state.intent?.constraints?.required_env_names);
  const include = options?.include_spel_seed !== false;

  const pack: IntentPackV1 = {
    schema: "kindred.intent_pack.v1",
    generator: {
      app_version: APP_VERSION,
      generated_at_utc: utcNow(),
    },
    project: {
      id: String(state.project?.id || "").trim(),
      name: String(state.project?.name || "").trim(),
      created_at_utc: String(state.project?.created_at_utc || "").trim(),
    },
    intent: {
      launch_path_id: state.intent?.launch_path_id,
      build_intent: state.intent?.build_intent,
      primary_surface: state.intent?.primary_surface,
      palettes: Array.isArray(state.intent?.palettes) ? state.intent.palettes.slice() : [],
      intake: (state.intent as any)?.intake,
      constraints: {
        offline_first: !!state.intent?.constraints?.offline_first,
        no_payments: !!state.intent?.constraints?.no_payments,
        required_env_names: required_env_names.length > 0 ? required_env_names : undefined,
      },
      brief: {
        audience_description: String(state.intent?.brief?.audience_description || ""),
        problem: String(state.intent?.brief?.problem || ""),
        offer: String(state.intent?.brief?.offer || ""),
        differentiators: safeList(state.intent?.brief?.differentiators),
        key_actions: safeList(state.intent?.brief?.key_actions),
        success_metrics: safeList(state.intent?.brief?.success_metrics),
        non_goals: safeList(state.intent?.brief?.non_goals),
      },
    },
    design: {
      brand: {
        name: String(state.design?.brand?.name || ""),
        tagline: String(state.design?.brand?.tagline || ""),
        audience: state.design?.brand?.audience || "general_public",
        tone: state.design?.brand?.tone || "friendly",
      },
      tokens: state.design?.tokens,
    },
  };

  if (include) {
    pack.spel_seed = {
      schema: "kindred.spel_seed.v1",
      text: generateSPELFromState(state),
    };
  }

  return pack;
}

export function buildPublicIntentPackFromState(state: ProjectState): IntentPackV1 {
  // Public intent pack omits Council DSL by default.
  return buildIntentPackFromStateWithOptions(state, { include_spel_seed: false });
}

export function buildIntentPackFromState(state: ProjectState): IntentPackV1 {
  // Backwards-compatible default: include Council DSL seed.
  return buildIntentPackFromStateWithOptions(state, { include_spel_seed: true });
}


export function spelSeedTextFromState(state: ProjectState): string {
  return generateSPELFromState(state);
}

export async function spelSeedSha256FromState(state: ProjectState): Promise<string> {
  return await sha256Hex(spelSeedTextFromState(state));
}

export async function intentPackSha256(pack: IntentPackV1): Promise<string> {
  // Hash the semantic content (ignore generated_at_utc so repeated exports are stable).
  const stable: IntentPackV1 = {
    ...pack,
    generator: { ...pack.generator, generated_at_utc: "" },
  };
  const text = stableJsonText(stable, 2);
  return sha256Hex(new TextEncoder().encode(text));
}

function cap<T>(arr: T[], max: number): T[] {
  return arr.slice(0, Math.max(0, max));
}

function uniq<T>(arr: T[]): T[] {
  return Array.from(new Set(arr));
}

function chooseExpansionPalettes(base: PaletteId[]): PaletteId[] {
  // A general-purpose “capabilities expansion” set that stays kernel-neutral.
  const extras: PaletteId[] = [
    "knowledge_learning",
    "matching_recommendation",
    "collaboration_work",
    "automation_workflows",
  ];
  return uniq([...base, ...extras]);
}

export function generateIntentProposalsFromState(state: ProjectState): IntentProposalV1[] {
  const build_intent = state.intent.build_intent || "website";
  const primary_surface = state.intent.primary_surface || "content_site";

  const rec = recommendedPalettes({
    build_intent,
    primary_surface,
    constraints: {
      offline_first: !!state.intent.constraints?.offline_first,
      no_payments: !!state.intent.constraints?.no_payments,
    },
  });

  const base = uniq([...(Array.isArray(state.intent.palettes) ? state.intent.palettes : []), ...rec.recommended]);

  const mvpPalettes = cap(base, 3);
  const balancedPalettes = cap(base, 6);
  const expansionPalettes = cap(chooseExpansionPalettes(base), 9);

  const proposals: IntentProposalV1[] = [
    {
      schema: "kindred.intent_proposal.v1",
      id: "mvp",
      title: "MVP (fast, minimal)",
      tagline: "Small scope, crisp pages, fewer moving parts.",
      rationale: [
        "Minimize scope to ship sooner.",
        "Reduce cognitive load for first-time users.",
        "Keep future expansion possible via palettes + proposals.",
      ],
      recommended: { build_intent, primary_surface, palettes: mvpPalettes },
      notes: [
        `Uses ${mvpPalettes.length} palettes to keep the starter structure small.`,
        "You can add capabilities later without rewriting your brief.",
      ],
    },
    {
      schema: "kindred.intent_proposal.v1",
      id: "balanced",
      title: "Balanced (product-ready)",
      tagline: "A credible starting shape with room for iteration.",
      rationale: [
        "Includes the most common supporting capabilities for your intent.",
        "Creates a richer starter IA without becoming a full platform.",
        "A good default for most directors.",
      ],
      recommended: { build_intent, primary_surface, palettes: balancedPalettes },
      notes: [
        `Uses ${balancedPalettes.length} palettes (recommended + your picks).`,
        "Best trade-off for early credibility vs complexity.",
      ],
    },
    {
      schema: "kindred.intent_proposal.v1",
      id: "expansion",
      title: "Expansion-ready (capabilities on deck)",
      tagline: "More capabilities surfaced now; still offline-first by default.",
      rationale: [
        "If your vision is broader, surface the domains early.",
        "Derives a bigger starter IA to reduce future migration pain.",
        "Still keeps deterministic control: nothing runs server-side.",
      ],
      recommended: { build_intent, primary_surface, palettes: expansionPalettes },
      notes: [
        `Uses ${expansionPalettes.length} palettes; expect more derived pages and scenes.`,
        "Adopt only if you’re ready to manage the extra surface area.",
      ],
    },
  ];

  return proposals;
}

export function applyIntentProposalToState(state: ProjectState, proposal: IntentProposalV1): ProjectState {
  const next: ProjectState = {
    ...state,
    intent: {
      ...state.intent,
      build_intent: proposal.recommended.build_intent,
      primary_surface: proposal.recommended.primary_surface,
      palettes: proposal.recommended.palettes.slice(),
    },
    director: {
      ...(state as any).director,
      schema: "kindred.director_state.v1",
      selected_intent_proposal_id: proposal.id,
      last_intent_proposals_generated_at_utc: utcNow(),
    },
  } as any;

  // Keep the derived UX/IA consistent with the new intent and palettes.
  return applyDerivedTemplates(next);
}
