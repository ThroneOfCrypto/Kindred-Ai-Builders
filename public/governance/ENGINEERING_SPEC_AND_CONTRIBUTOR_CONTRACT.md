# SDDE OS / Design to Ship with AI
## Engineering Spec, Telos, and Absolute Contributor Rules
**Status:** Normative • **Applies to:** Book + Embedded Repo + Kindred AI Builders repo  
**Last updated:** 2026-01-05 (Europe/London)  
**Authority:** This document is the gatekeeper. If a change conflicts with this document, the change is invalid.

---

## 0) Telos (the purpose that governs every decision)

SDDE OS exists to make it honestly true that:

> A beginner can build and ship a real, robust product by making bounded, deterministic decisions—while an AI “Council” does the expert work under contract, with proof, governance, and escape hatches.

The finished system (book + repo + builder UI) must enable:

1. **Deterministic intent capture** (no “free-text requirements slot machine”)
2. **Proposal-only AI** (AI suggests; never silently edits)
3. **Explicit adoption + locking** (human authority boundaries)
4. **Verifiable artefacts** (packs, hashes, schemas, gate reports, evidence cards)
5. **Offline-first beginner experience** (no paid infra required to learn/use)
6. **Kernel neutrality** (no vendor/product lock-in; specifics live in optional Kits)
7. **Upgradeable rigor** (Safe/Strict/Audit) without changing the core method

**Non-goal:** SDDE OS is not “prompt engineering.” Prompts are implementation details; contracts and artefacts are the truth.

---

## 1) Scope and “truth lives in artefacts”

This contract governs:

- The **book manuscript** (including embedded runnable repo blocks)
- The **embedded repo** inside the book
- The **Kindred AI Builders** UI repo that operationalizes the method
- Any tools that generate/verify/compile packs, schemas, or gate reports

### 1.1 Source of truth hierarchy (highest to lowest)

1) **Normative governance files** (this doc + contracts + schemas)  
2) **Artefacts** generated by tools (packs, hashes, reports, evidence ledgers)  
3) **Repo code** (tools + UI)  
4) **Book narrative** (must match reality; never contradict artefacts)  
5) **Chat** (control surface only; never source of truth)

If any two levels disagree, **higher wins**.

---

## 2) Core ontology (non-negotiable terms)

### 2.1 Palettes / Domains / Kits (the required abstraction)
- **Palettes** are the primary ontology. They are the canonical high-level capability bundles:
  - Identity & Access
  - Communication & Social Surfaces
  - Content & Media
  - Knowledge & Learning
  - Search/Navigation & Discovery
  - Matching & Recommendation
  - Collaboration & Work
  - Commerce & Value Exchange
  - Governance/Rules & Policy
  - Reputation/Trust & Safety
  - Game & Incentive Mechanics
  - Automation/Agents/Workflows
  - Infrastructure/Data/Files
  - Connection/Integration
- **Domains** are advanced, optional DSL layers on top of palettes.
- **Kits** are product/provider bindings (optional, not kernel).

**Rule:** Kernel flows must be expressed in palettes; Kits may add stack-specific wiring.

### 2.2 Council (AI) boundary
The “Council” is a set of agent roles (Architect/Builder/Critic/Scribe/Guardians, etc.) that:
- proposes changes
- produces artefacts
- never crosses authority boundaries

**Rule:** Council outputs are always proposals until explicitly adopted.

---

## 3) Absolute invariants (MUST NOT be violated)

This section is the “constitution.” Any change that violates these must be rejected.

### 3.1 Deterministic beginner intake (NO_FREE_TEXT_INTAKE_V1)
- Beginner intent MUST be captured as **schema-locked structured choices**.
- Free text may exist only as:
  - labels
  - non-normative notes (Advanced-only by default)
- Free text MUST NOT be treated as requirements, compilation inputs, or truth.

### 3.2 No-elision code fences (book and docs)
Any fenced block in `python`, `js`, `bash`, `json`, `yaml`, `toml`, etc. MUST:
- run/parse **as-is**
- contain no `...` ellipses
- contain no “TODO stubs”
- include complete imports and definitions
- include correct commands and paths

If a fence cannot be runnable, it MUST be labeled clearly as **non-runnable** and MUST NOT be required by the flow.

### 3.3 Proposal-only AI + explicit adoption
- AI may propose diffs/patches/changes.
- The system MUST require an explicit “Adopt” action before any change becomes canonical.
- “Lock” actions MUST be explicit, irreversible without an explicit “Unlock” action.

### 3.4 Deterministic packs and hashes
- Packs (Spec Pack / Repo Pack / Evidence Bundle) MUST be deterministic:
  - stable file ordering
  - stable timestamps (e.g., ZIP_MTIME_UTC)
  - stable JSON serialization (stable key ordering)
- Hashes MUST be reproducible for identical inputs.

### 3.5 Offline-first kernel
The kernel MUST run without:
- paid services
- accounts
- cloud dependencies
- network calls

Network-backed capabilities MAY exist only as opt-in Kits.

### 3.6 Kernel neutrality
Kernel MUST NOT depend on a specific vendor/provider/stack.
- Provider APIs, SDKs, proprietary formats, and third-party account flows MUST be isolated into Kits.
- The kernel MUST always provide a “portable artefacts” exit hatch.

### 3.7 Evidence-first shipping
Every “Ship/Deploy/Release” claim MUST be backed by:
- a gate report
- stored evidence (local-first, exportable)
- hash-linked artefacts

No feature may claim reliability without evidence.

---

## 4) Engineering spec (system-level behavior)

### 4.1 The Director stream (single coherent rail)
The default beginner experience MUST be a single, coherent rail:

**Spark → Shape → Decide → Prove → Ship → Deploy → Observe → Improve**

Each step MUST provide:
- **one primary next action**
- **one produced artefact**
- **one proof/record** (hash/report/evidence card)

No dead ends. No “blank canvas requirement entry.”

### 4.2 Artefact spine (required files and meanings)

#### 4.2.1 Spec Pack (portable, deterministic zip)
MUST contain (minimum):
- `spec_pack_manifest.json` (schema + versions + file list)
- `project/meta.json`
- `contracts/rigor.json` (portable rigor contract)
- `intent/*`:
  - `launch_path.json`
  - `build_intent.json`
  - `targets.json`
  - `palettes.json`
  - `constraints.json`
  - `intake.json` (schema-locked intake)
  - `selections.json` (snapshot + adopted IDs + provenance pointers)
  - `brief.json` (derived, human-facing)
- `design/*`, `ux/*`, `content/*`, `brownfield/*`
- `dist/builder_gate_report.json` (when available)

**Council DSL (SPEL/SPEL-like)**
- MUST be **advanced-only** by default.
- MAY be included when explicitly requested (advanced export or audit builds).

#### 4.2.2 Repo Pack (shippable code output)
MUST:
- embed a Spec Pack (or its extracted files)
- include lock metadata + provenance
- include reproducible build instructions
- remain portable (no hidden infrastructure)

#### 4.2.3 Evidence Ledger (local-first, exportable)
MUST:
- record key events (lock/unlock, verify runs, failure saves, adoptions)
- be exportable via Backup ZIP and/or Evidence Bundle
- be restorable without data loss

### 4.3 Rigor Dial (Safe / Strict / Audit)
- **Safe (default):** warnings allowed but recorded.
- **Strict:** warnings block “Ready to ship” for core gates.
- **Audit:** strict + requires more proof artefacts (e.g., schema validation evidence, provenance checks).

Rigor MUST be:
- visible in Ship
- stored locally
- exported as `contracts/rigor.json`
- validated by schemas

### 4.4 Advanced Mode (tinker ceiling)
Advanced Mode MUST:
- be OFF by default
- be explicit opt-in
- unlock:
  - Council DSL previews/exports
  - deeper audits
  - additional export buttons
- NEVER be required for completing the beginner golden path.

---

## 5) Absolute contributor rules (writing + code)

These rules are absolute. If you cannot comply, do not change the book or repo.

### 5.1 Change protocol (mandatory workflow)
Every change MUST follow:

1) **Declare intent**
   - What invariant(s) does this change preserve?
   - What artefact does it add/modify?
2) **Make the change**
3) **Run gates**
   - Typecheck/build/test
   - Pack validation
   - Golden path smoke run (when applicable)
4) **Update artefacts**
   - Schemas (if shape changed)
   - Validation registry
   - Docs (if user-facing behavior changed)
   - Evidence card for the change (when applicable)
5) **Version bump** (if repo behavior changes)
6) **Ship a deterministic artefact** (zip, report, patch)

**Rule:** No “just code changes” without updating the artefact spine and docs.

### 5.2 Writing rules (book + docs)
Writers MUST:
- write for a beginner, not for “prompt culture”
- avoid chatty “as an AI” voice
- keep narrative and procedures separated:
  - **Essay voice** for mental models and story
  - **Docs voice** for gates and how-to
- ensure every claim is backed by runnable code or an artefact
- never contradict the repo behavior
- never instruct “do X manually” when the repo can/should do it deterministically

**Rule:** If the book says “run this,” it MUST run.

### 5.3 Code rules (repo)
Coders MUST:
- keep kernel offline-first; any network calls must be behind Kit + explicit config
- keep exports deterministic (stable JSON and ZIP)
- add schemas for new artefacts
- add validation for new artefacts
- maintain explicit authority boundaries (adopt/lock)
- avoid adding new beginner-facing surfaces unless absolutely required:
  - prefer adding to the Ship rail
  - prefer progressive disclosure via Advanced Mode

### 5.4 Safety + privacy rules
- Secrets/keys MUST be stored locally by default.
- Never log secrets.
- No telemetry by default.
- BYO accounts are opt-in and must be treated as Kits.

### 5.5 Backwards compatibility rules
- Existing packs must remain readable.
- If schemas evolve:
  - introduce `v2` alongside `v1`
  - provide migration logic
  - keep validators tolerant with warnings where safe

### 5.6 Style and quality rules
- Prefer small, shippable cycles.
- No large refactors without Transition Mode and a checkpoint artefact.
- Every new concept must come with:
  - a definition
  - a file/contract shape
  - a gate/validator
  - a worked example

---

## 6) Definition of Done (DoD)

A change is “done” only if all are true:

- [ ] All invariants in §3 remain true
- [ ] Relevant schemas updated/added
- [ ] Validation updated (registry + checks)
- [ ] UI has no dead ends in the beginner rail
- [ ] Advanced-only features are gated and not required
- [ ] Build/typecheck passes
- [ ] Packs remain deterministic
- [ ] Evidence exists for the change (where applicable)
- [ ] Docs/book updated for any user-facing change
- [ ] Version bumped if behavior changed

---

## 7) Refusal criteria (when a change MUST be rejected)

Reject any change that:
- adds free-text requirement intake to the beginner flow
- exposes Council DSL by default (without explicit advanced opt-in)
- adds silent AI edits
- breaks determinism of packs/hashes
- adds mandatory cloud dependencies to the kernel
- violates kernel neutrality (bakes in a vendor)
- introduces runnable fences that don’t run
- claims “ready to ship” without evidence

---

## 8) Short contributor oath
By editing this book or repo, you agree:
- truth lives in files and contracts
- deterministic intake beats vibes
- AI suggests; humans adopt
- every ship claim requires evidence

---

## Appendix A: Required schemas and locations
Minimum required schema directory:
- `contracts/schemas/` — JSON schemas for artefacts

Minimum required contract artefacts (Spec Pack):
- `contracts/rigor.json`
- `spec_pack_manifest.json`
- `intent/intake.json`
- `intent/selections.json`

---

## Appendix B: “One-rail” step mapping (recommended)
This is the recommended mapping for the Ship checklist:

1) Lock Spec Pack  
   Artefact: `spec_pack.zip` + `spec_pack_manifest.json`  
   Proof: gate report + spec hash

2) Compile Blueprint  
   Artefact: blueprint output (and optional Council DSL in Advanced)  
   Proof: compile report + hash

3) Compile/Lock Repo Pack  
   Artefact: `repo_pack.zip` + provenance pointers  
   Proof: build hash + lock evidence

4) Verify  
   Artefact: verify report json  
   Proof: evidence card

5) Backup  
   Artefact: backup zip (includes evidence + rigor)  
   Proof: backup hash

6) Release  
   Artefact: tagged release zip + release notes  
   Proof: CI report (when present)

---

**End of contract.**
