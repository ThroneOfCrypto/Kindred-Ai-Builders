import fs from 'node:fs/promises';
import path from 'node:path';
import crypto from 'node:crypto';

const root = process.cwd();
const distDir = path.join(root, 'dist');
const outDir = path.join(root, 'public', 'proof');
const targetPacksDir = path.join(distDir, 'target_packs');

function escHtml(s) {
  return String(s)
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#39;');
}

function sha256(buf) {
  return crypto.createHash('sha256').update(buf).digest('hex');
}

async function exists(p) {
  try {
    await fs.access(p);
    return true;
  } catch {
    return false;
  }
}

async function walkFiles(rootDir) {
  const out = [];
  const stack = [''];
  while (stack.length) {
    const rel = stack.pop();
    const full = path.join(rootDir, rel);
    const st = await fs.stat(full);
    if (st.isDirectory()) {
      const names = (await fs.readdir(full)).slice().sort();
      for (const name of names) {
        const childRel = rel ? path.join(rel, name) : name;
        stack.push(childRel);
      }
      continue;
    }
    out.push(rel);
  }
  return out.sort();
}

const allow = [
  'proof_graph.v1.json',
  'proof_graph.v1.dot',
  'proof_graph_validate.report.json',
  'evaluation_pack.report.json',
  'spel_counterexample_minimal.report.json',
  'spel_federation_immiscibility.report.json',
  'interop_proof_pack.report.json',
  'periodic_contracts_phase0.report.json',
  'periodic_contracts_phase1.report.json',
  'periodic_trace_stability.report.json',
  'periodic_system_order_stability.report.json',
  'periodic_compound_order_stability.report.json'
];

await fs.mkdir(outDir, { recursive: true });

const copied = [];
const missing = [];

for (const file of allow) {
  const src = path.join(distDir, file);
  const dst = path.join(outDir, file);
  if (!(await exists(src))) {
    missing.push(file);
    continue;
  }
  const buf = await fs.readFile(src);
  await fs.writeFile(dst, buf);
  copied.push({ file, bytes: buf.length, sha256: sha256(buf) });
}

// Publish target kit packs (dist/target_packs/**) as static proof artifacts.
// This is explicitly non-authoritative for the kernel (diagnostic lane only),
// but it must still be hashable and hostile-reader-safe.
if (await exists(targetPacksDir)) {
  const relFiles = await walkFiles(targetPacksDir);
  for (const rel of relFiles) {
    const src = path.join(targetPacksDir, rel);
    const dst = path.join(outDir, 'target_packs', rel);
    const buf = await fs.readFile(src);
    await fs.mkdir(path.dirname(dst), { recursive: true });
    await fs.writeFile(dst, buf);
    copied.push({ file: `target_packs/${rel.replace(/\\/g, '/')}`, bytes: buf.length, sha256: sha256(buf) });
  }
}

// Deterministic static manifest for hostile readers (and future you).
const manifest = {
  ok: true,
  tool: 'proof_publish_static',
  out_dir: path.relative(root, outDir),
  files: copied
    .slice()
    .sort((a, b) => a.file.localeCompare(b.file))
    .map((x) => ({ file: x.file, bytes: x.bytes, sha256: x.sha256 })),
  missing: missing.slice().sort(),
};

await fs.writeFile(
  path.join(outDir, 'proof_manifest.v1.json'),
  JSON.stringify(manifest, null, 2)
);

// Human-readable index page (static, deterministic ordering).
const rows = manifest.files
  .map((f) => {
    const href = escHtml(f.file);
    const bytes = escHtml(String(f.bytes));
    const digest = escHtml(f.sha256);
    return `<tr><td><a href="${href}">${href}</a></td><td class="mono">${bytes}</td><td class="mono">${digest}</td></tr>`;
  })
  .join('\n');

const missingRows = manifest.missing.length
  ? `<h2>Missing (expected but not found)</h2><ul>${manifest.missing
      .map((m) => `<li class="mono">${escHtml(m)}</li>`)
      .join('')}</ul>`
  : '';

const indexHtml = `<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Kindred Proof Artifacts</title>
    <style>
      body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;padding:24px;max-width:980px;margin:0 auto;line-height:1.4}
      h1{margin:0 0 8px 0}
      p{margin:8px 0 18px 0;color:#333}
      table{border-collapse:collapse;width:100%}
      th,td{border:1px solid #ddd;padding:10px;vertical-align:top}
      th{background:#f6f6f6;text-align:left}
      a{color:inherit}
      .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px}
      .subtle{color:#666}
    </style>
  </head>
  <body>
    <h1>Proof Artifacts</h1>
    <p class="subtle">Generated by <span class="mono">tools/proof_publish_static.mjs</span>. Deterministic list + sha256 digests.</p>

    <p><a href="proof_manifest.v1.json">proof_manifest.v1.json</a></p>

    <table>
      <thead>
        <tr><th>File</th><th>Bytes</th><th>sha256</th></tr>
      </thead>
      <tbody>
        ${rows}
      </tbody>
    </table>

    ${missingRows}
  </body>
</html>`;

await fs.writeFile(path.join(outDir, 'index.html'), indexHtml);

const report = {
  ok: true,
  tool: 'proof_publish_static',
  out_dir: path.relative(root, outDir),
  copied,
  missing,
};

await fs.writeFile(path.join(distDir, 'proof_publish_static.report.json'), JSON.stringify(report, null, 2));

console.log(`[proof_publish_static] copied=${copied.length} missing=${missing.length} -> ${path.relative(root, outDir)}`);
